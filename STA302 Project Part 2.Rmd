---
title: "STA302 Project Part 2"
output: pdf_document
date: "2025-11-25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# ------------------ 0) Load libraries ------------------
pkgs <- c("tidyverse", "broom", "car", "MASS", "lmtest", "sandwich", "caret", "Metrics", "ggplot2")
invisible(lapply(pkgs, function(p) if(!requireNamespace(p, quietly = TRUE)) install.packages(p)))
library(tidyverse); library(broom); library(car); library(MASS); library(lmtest); library(sandwich); library(caret); library(Metrics); library(ggplot2)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
# ------------------ 1) Load data ------------------
spotify <- read_csv("spotify-2023.csv")

# ------------------ 2) Clean / rename columns ------------------
spotify <- spotify %>%
  rename_with(~ gsub("%", "pct", .x, fixed = TRUE)) %>%
  rename_with(~ make.names(.x)) %>%
  mutate(
    streams = as.numeric(streams),
    in_spotify_playlists = as.numeric(in_spotify_playlists),
    danceability_pct = as.numeric(danceability_pct),
    energy_pct = as.numeric(energy_pct),
    valence_pct = as.numeric(valence_pct),
    artist_count = as.integer(artist_count),
    released_year = as.integer(released_year)
  ) %>%
  drop_na(streams, in_spotify_playlists, danceability_pct, energy_pct, valence_pct, artist_count, released_year)

# ------------------ 3) Fit raw model ------------------
model_raw <- lm(streams ~ in_spotify_playlists + danceability_pct + energy_pct +
                  valence_pct + artist_count + released_year +
                  danceability_pct * energy_pct,
                data = spotify)
summary(model_raw)

# ------------------ 4) Fit log-transformed model (heteroskedasticity fix) ------------------
spotify <- spotify %>% mutate(log_streams = log1p(streams))
model_log <- lm(log_streams ~ in_spotify_playlists + danceability_pct + energy_pct +
                  valence_pct + artist_count + released_year +
                  danceability_pct * energy_pct,
                data = spotify)
summary(model_log)

# ------------------ 5) Optionally add quadratic term to improve linearity ------------------
model_quad <- lm(log_streams ~ in_spotify_playlists + I(in_spotify_playlists^2) +
                   danceability_pct + I(danceability_pct^2) +
                   energy_pct + I(energy_pct^2) +
                   valence_pct + artist_count + released_year +
                   danceability_pct * energy_pct,
                 data = spotify)
summary(model_quad)

# ------------------ 6) Residual diagnostics ------------------
resid_before <- augment(model_raw)
resid_after <- augment(model_log)

# Residual vs Fitted (Raw)
p_resid_raw <- ggplot(resid_before, aes(x = .fitted, y = .resid)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype = 2) +
  labs(title = "Residuals vs Fitted (Raw Model)", x = "Fitted values", y = "Residuals") +
  theme_minimal()
ggsave("figures/resid_vs_fitted_raw.png", p_resid_raw, width = 6, height = 4, dpi = 300)

# Residual vs Fitted (Log)
p_resid_log <- ggplot(resid_after, aes(x = .fitted, y = .resid)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype = 2) +
  labs(title = "Residuals vs Fitted (Log-Transformed Model)", x = "Fitted values", y = "Residuals") +
  theme_minimal()
ggsave("figures/resid_vs_fitted_log.png", p_resid_log, width = 6, height = 4, dpi = 300)

# QQ Plots
p_qq_raw <- ggplot(resid_before, aes(sample = .resid)) +
  stat_qq() + stat_qq_line() +
  labs(title = "QQ Plot of Residuals (Raw Model)") +
  theme_minimal()
ggsave("figures/qq_resid_raw.png", p_qq_raw, width = 6, height = 4, dpi = 300)

p_qq_log <- ggplot(resid_after, aes(sample = .resid)) +
  stat_qq() + stat_qq_line() +
  labs(title = "QQ Plot of Residuals (Log-Transformed Model)") +
  theme_minimal()
ggsave("figures/qq_resid_log.png", p_qq_log, width = 6, height = 4, dpi = 300)

# Scale-Location plots
p_scale_raw <- ggplot(resid_before, aes(x = .fitted, y = sqrt(abs(.resid)))) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "loess", se = FALSE) +
  labs(title = "Scale-Location (Raw Model)", x = "Fitted values", y = "Sqrt(|Residuals|)") +
  theme_minimal()
ggsave("figures/scale_location_raw.png", p_scale_raw, width = 6, height = 4, dpi = 300)

p_scale_log <- ggplot(resid_after, aes(x = .fitted, y = sqrt(abs(.resid)))) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "loess", se = FALSE) +
  labs(title = "Scale-Location (Log Model)", x = "Fitted values", y = "Sqrt(|Residuals|)") +
  theme_minimal()
ggsave("figures/scale_location_log.png", p_scale_log, width = 6, height = 4, dpi = 300)

# ------------------ 7) Optional: Box-Cox ------------------
if(all(spotify$streams > 0)) {
  bc <- boxcox(model_raw, lambda = seq(-1, 2, 0.05), plotit = FALSE)
  lambda_opt <- bc$x[which.max(bc$y)]
  cat("Box-Cox suggested lambda =", lambda_opt, "\n")
}

# ------------------ 8) Interaction plot ------------------
dance_seq <- seq(min(spotify$danceability_pct), max(spotify$danceability_pct), length.out = 100)
energy_quants <- quantile(spotify$energy_pct, c(0.25, 0.5, 0.75))
newdata <- expand.grid(
  in_spotify_playlists = median(spotify$in_spotify_playlists),
  danceability_pct = dance_seq,
  energy_pct = energy_quants,
  valence_pct = median(spotify$valence_pct),
  artist_count = round(median(spotify$artist_count)),
  released_year = round(median(spotify$released_year))
)
newdata$pred <- predict(model_log, newdata = newdata)
newdata <- newdata %>%
  mutate(energy_level = factor(case_when(
    energy_pct == energy_quants[1] ~ "Low (25th pctile)",
    energy_pct == energy_quants[2] ~ "Median (50th pctile)",
    energy_pct == energy_quants[3] ~ "High (75th pctile)"
  ), levels = c("Low (25th pctile)", "Median (50th pctile)", "High (75th pctile)")))

p_interaction <- ggplot(newdata, aes(x = danceability_pct, y = expm1(pred), color = energy_level)) +
  geom_line(size = 1) +
  labs(title = "Interaction: Predicted Streams by Danceability across Energy Levels",
       x = "Danceability (%)", y = "Predicted Streams", color = "Energy Level") +
  theme_minimal()
ggsave("figures/interaction_pred_streams_log_backtrans.png", p_interaction, width = 7, height = 4, dpi = 300)

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
# ------------------ 7) Figure A: Histograms / density plots for streams, danceability_pct, energy_pct ------------------
# A1: Streams histogram + density
p_streams <- ggplot(spotify, aes(x = streams)) +
  geom_histogram(bins = 60, alpha = 0.8) +
  labs(title = "Histogram of Spotify Streams", x = "Streams", y = "Count") +
  theme_minimal()
ggsave("figures/hist_streams.png", p_streams, width = 6, height = 4, dpi = 300)

# A2: Streams (log) histogram — often more informative
p_log_streams <- ggplot(spotify, aes(x = log1p(streams))) +
  geom_histogram(bins = 60, alpha = 0.8) +
  labs(title = "Histogram of log(1 + Streams)", x = "log(1 + Streams)", y = "Count") +
  theme_minimal()
ggsave("figures/hist_log_streams.png", p_log_streams, width = 6, height = 4, dpi = 300)

# A3: Danceability density/hist
p_dance <- ggplot(spotify, aes(x = danceability_pct)) +
  geom_density() +
  geom_rug(alpha = 0.2) +
  labs(title = "Density of Danceability (%)", x = "Danceability (%)") +
  theme_minimal()
ggsave("figures/density_danceability.png", p_dance, width = 5, height = 3.5, dpi = 300)

# A4: Energy density/hist
p_energy <- ggplot(spotify, aes(x = energy_pct)) +
  geom_density() +
  geom_rug(alpha = 0.2) +
  labs(title = "Density of Energy (%)", x = "Energy (%)") +
  theme_minimal()
ggsave("figures/density_energy.png", p_energy, width = 5, height = 3.5, dpi = 300)

# ------------------ 8) Figure B: Clean coefficient table plot (dot-and-whisker) ------------------
# Use broom::tidy to make a plot of estimates with 95% CIs
coefs_plot_dat <- broom::tidy(model_raw) %>%
  filter(term != "(Intercept)") %>%
  mutate(term = fct_reorder(term, estimate))

p_coefs <- ggplot(coefs_plot_dat, aes(x = estimate, y = term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = estimate - 1.96*std.error, xmax = estimate + 1.96*std.error), height = 0.2) +
  labs(title = "Coefficient Estimates (raw streams model)", x = "Estimate", y = "") +
  theme_minimal()
ggsave("figures/coef_estimates_raw.png", p_coefs, width = 7, height = 4, dpi = 300)

# Also export a neat table for the poster (rounded)
coefs_table <- broom::tidy(model_raw) %>%
  mutate(estimate = round(estimate, 0),
         std.error = round(std.error, 0),
         p.value = signif(p.value, 3)) %>%
  select(term, estimate, std.error, p.value)
write_csv(coefs_table, "figures/coef_table_raw.csv")

# ------------------ 9) Figure C: Interaction plot (predicted streams across danceability at low/med/high energy) ------------------
# Create grid of danceability_pct and energy_pct values
dance_seq <- seq(min(spotify$danceability_pct, na.rm = TRUE),
                 max(spotify$danceability_pct, na.rm = TRUE), length.out = 100)
energy_low <- quantile(spotify$energy_pct, 0.25, na.rm = TRUE)
energy_med <- quantile(spotify$energy_pct, 0.5, na.rm = TRUE)
energy_high <- quantile(spotify$energy_pct, 0.75, na.rm = TRUE)

newdata <- expand.grid(
  in_spotify_playlists = median(spotify$in_spotify_playlists, na.rm = TRUE),
  danceability_pct = dance_seq,
  energy_pct = c(energy_low, energy_med, energy_high),
  valence_pct = median(spotify$valence_pct, na.rm = TRUE),
  artist_count = round(median(spotify$artist_count, na.rm = TRUE)),
  released_year = round(median(spotify$released_year, na.rm = TRUE))
)

# Predict using the raw model (on original scale)
newdata$pred_streams <- predict(model_raw, newdata = newdata, interval = "confidence")[, "fit"]
# Bind energy level labels
newdata <- newdata %>%
  mutate(energy_level = case_when(
    energy_pct == energy_low ~ "Low energy (25th pctile)",
    energy_pct == energy_med ~ "Median energy (50th pctile)",
    energy_pct == energy_high ~ "High energy (75th pctile)"
  ))

p_interaction <- ggplot(newdata, aes(x = danceability_pct, y = pred_streams, color = energy_level)) +
  geom_line(size = 1) +
  labs(title = "Interaction: Predicted Streams by Danceability across Energy Levels",
       x = "Danceability (%)", y = "Predicted Streams", color = "Energy level") +
  theme_minimal()
ggsave("figures/interaction_pred_streams_raw.png", p_interaction, width = 7, height = 4, dpi = 300)

# If you'd prefer the interaction plot on log-scale predictions (often clearer):
newdata$pred_log <- predict(model_log, newdata = newdata, interval = "confidence")[, "fit"]
p_interaction_log <- ggplot(newdata, aes(x = danceability_pct, y = expm1(pred_log), color = energy_level)) +
  geom_line(size = 1) +
  labs(title = "Interaction (log-model back-transformed): Predicted Streams by Danceability",
       x = "Danceability (%)", y = "Predicted Streams (back-transformed)") +
  theme_minimal()
ggsave("figures/interaction_pred_streams_log_backtrans.png", p_interaction_log, width = 7, height = 4, dpi = 300)

# ------------------ 10) Figure D: Residual diagnostics ------------------
# Residual vs Fitted Plot — BEFORE Fix
resid_dat <- augment(model_raw)
p_resid_fitted <- ggplot(resid_dat, aes(x = .fitted, y = .resid)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype = 2) +
  labs(title = "Residuals vs Fitted (raw model)", x = "Fitted values", y = "Residuals") +
  theme_minimal()
ggsave("figures/resid_vs_fitted_raw.png", p_resid_fitted, width = 6, height = 4, dpi = 300)

# Residual vs Fitted Plot - TRY LOG ON Y
lnStreams <- log(spotify$streams)
model2 <- lm(lnStreams ~ in_spotify_playlists + danceability_pct + energy_pct +
           valence_pct + artist_count + released_year +
           danceability_pct * energy_pct,
         data = spotify)
e_hat <- resid(model2)
y_hat <- fitted(model2)
p_resid_fitted <- ggplot(spotify, aes(x = e_hat, y = y_hat)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype = 2) +
  labs(title = "Residuals vs Fitted (transformed model)", x = "Fitted values", y = "Residuals") +
  theme_minimal()
ggsave("figures/resid_vs_fitted_transformed.png", p_resid_fitted, width = 6, height = 4, dpi = 300)

# Residual vs Fitted Plot - BOX-COX ON Y
powerTransform(model1)
transStreams <- (spotify$streams)^0.2
model3 <- lm(transStreams ~ in_spotify_playlists + danceability_pct + energy_pct +
           valence_pct + artist_count + released_year +
           danceability_pct * energy_pct,
         data = spotify)
e_hat <- resid(model3)
y_hat <- fitted(model3)
p_resid_fitted <- ggplot(spotify, aes(x = e_hat, y = y_hat)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype = 2) +
  labs(title = "Residuals vs Fitted (transformed model)", x = "Fitted values", y = "Residuals") +
  theme_minimal()
ggsave("figures/resid_vs_fitted_transformed.png", p_resid_fitted, width = 6, height = 4, dpi = 300)

# Residual vs Fitted Plot - BOX-COX ON X
p <- powerTransform(cbind(resid_dat[,2:6]))
summary(p)
model4 <- lm(streams ~ log(in_spotify_playlists) + log(danceability_pct) + log(energy_pct) +
           sqrt(valence_pct) + 1/artist_count + log(released_year) +
           log(danceability_pct * energy_pct),
         data = spotify)
e_hat <- resid(model4)
y_hat <- fitted(model4)
plot(e_hat ~ y_hat, xlab="Fitted Values", ylab="Residuals")
plot(e_hat ~ log(spotify$in_spotify_playlists), xlab="ln(in_spotify_playlists)", ylab="Residuals")
plot(e_hat ~ log(spotify$danceability_pct), xlab="ln(AdPages)", ylab="Residuals")
plot(e_hat ~ log(spotify$energy_pct), xlab="ln(SubRevenue)", ylab="Residuals")
plot(e_hat ~ sqrt(spotify$valence_pct), xlab="ln(NewsRevenue)", ylab="Residuals")
plot(e_hat ~ 1/(spotify$artist_count), xlab="ln(NewsRevenue)", ylab="Residuals")
plot(e_hat ~ log(spotify$released_year), xlab="ln(SubRevenue)", ylab="Residuals")
plot(e_hat ~ log(spotify$danceability_pct * spotify$energy_pct), xlab="ln(SubRevenue)", ylab="Residuals")
qqnorm(e_hat); qqline(e_hat)

p <- powerTransform(cbind(resid_dat[,1:6]))
summary(p)
model5 <- lm(transStreams ~ log(in_spotify_playlists) + log(danceability_pct) + log(energy_pct) +
           sqrt(valence_pct) + 1/artist_count + log(released_year) +
           log(danceability_pct * energy_pct),
         data = spotify)
e_hat <- resid(model5)
y_hat <- fitted(model5)
plot(e_hat ~ y_hat, xlab="Fitted Values", ylab="Residuals")
plot(e_hat ~ log(spotify$in_spotify_playlists), xlab="ln(AdPages)", ylab="Residuals")
plot(e_hat ~ log(spotify$danceability_pct), xlab="ln(AdPages)", ylab="Residuals")
plot(e_hat ~ log(spotify$energy_pct), xlab="ln(SubRevenue)", ylab="Residuals")
plot(e_hat ~ sqrt(spotify$valence_pct), xlab="ln(NewsRevenue)", ylab="Residuals")
plot(e_hat ~ 1/(spotify$artist_count), xlab="ln(NewsRevenue)", ylab="Residuals")
plot(e_hat ~ log(spotify$released_year), xlab="ln(SubRevenue)", ylab="Residuals")
plot(e_hat ~ log(spotify$danceability_pct * spotify$energy_pct), xlab="ln(SubRevenue)", ylab="Residuals")
qqnorm(e_hat); qqline(e_hat)

# Residual vs Fitted Plot — AFTER Fix
resid_dat_after <- augment(lm(log(streams) ~ in_spotify_playlists + danceability_pct + energy_pct +
           valence_pct + artist_count + released_year +
           danceability_pct * energy_pct,
         data = spotify))
p_resid_fitted_after <- ggplot(resid_dat_after, aes(x = .fitted, y = .resid)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype = 2) +
  labs(title = "Residuals vs Fitted (log-transformed model)",
       x = "Fitted values",
       y = "Residuals") +
  theme_minimal()
ggsave("figures/resid_vs_fitted_log.png", p_resid_fitted_after,
       width = 6, height = 4, dpi = 300)

# Residuals vs in_spotify_playlists (to check heteroskedasticity vs exposure)
p_resid_spotifyPlaylists <- ggplot(resid_dat, aes(x = in_spotify_playlists, y = .resid)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "loess", se = FALSE) +
  labs(title = "Residuals vs In-Spotify-Playlists", x = "In Spotify playlists", y = "Residuals") +
  theme_minimal()
ggsave("figures/resid_vs_spotify_playlists_raw.png", p_resid_spotifyPlaylists, width = 6, height = 4, dpi = 300)

# QQ-plot of residuals
p_qq <- ggplot(resid_dat, aes(sample = .resid)) +
  stat_qq() +
  stat_qq_line() +
  labs(title = "Normal Q-Q Plot of Residuals (raw model)") +
  theme_minimal()
ggsave("figures/qqplot_resid_raw.png", p_qq, width = 6, height = 4, dpi = 300)

# Scale-Location plot (sqrt(|resid|)
p_scale_loc <- ggplot(resid_dat, aes(x = .fitted, y = sqrt(abs(.resid)))) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "loess", se = FALSE) +
  labs(title = "Scale-Location Plot", x = "Fitted values", y = "Sqrt(|Residuals|)") +
  theme_minimal()
ggsave("figures/scale_location_raw.png", p_scale_loc, width = 6, height = 4, dpi = 300)

# ------------------ 11) Optional: Save model summaries and diagnostics to files ------------------
capture.output(summary_raw, file = "figures/model_raw_summary.txt")
capture.output(vif_df, file = "figures/vif_values.txt")
capture.output(summary(model_log), file = "figures/model_log_summary.txt")

# ------------------ 12) Notes for poster captions & interpretation (print a short summary) ------------------
cat("\n\n=== Poster notes (copy into poster): ===\n")
cat("- Model formula (raw):", deparse(formula_raw), "\n")
cat("- Top results: inspect 'figures/coef_table_raw.csv' and 'figures/coef_estimates_raw.png'\n")
cat("- Interaction plot saved to: figures/interaction_pred_streams_raw.png (raw) and figures/interaction_pred_streams_log_backtrans.png (log-model back-transformed)\n")
cat("- Diagnostics saved to: figures/resid_vs_fitted_raw.png, figures/resid_vs_spotify_playlists_raw.png, figures/qqplot_resid_raw.png, figures/scale_location_raw.png\n")
cat("- Consider reporting results from the log-model (figures/model_log_summary.txt) if heteroskedasticity present.\n")
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
