---
title: "STA302 Project Part 2"
output: pdf_document
date: "2025-11-25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Required packages - install if missing
pkgs <- c("tidyverse", "broom", "car", "ggplot2", "ggpubr", "sjPlot", "effects", "emmeans")
install_if_missing <- function(p) {
  if (!requireNamespace(p, quietly = TRUE)) install.packages(p)
}
invisible(lapply(pkgs, install_if_missing))
library(tidyverse)
library(broom)
library(modelsummary)
library(ggplot2)
library(car)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
# ------------------ 1) Load data ------------------
# Replace path with your file path if needed
spotify <- read_csv("spotify-2023.csv")
# If you already have spotify loaded, skip the read_csv line above.

# Example: uncomment and set your path
# spotify <- read_csv("/Users/yourname/path/to/spotify-2023.csv")

# Quick check
if (!exists("spotify")) stop("Please load your dataset into the object `spotify` before running this script.")

# ------------------ 2) Clean / rename columns ------------------
# Change names that have '%' or other characters into safe R names
spotify <- spotify %>%
  rename_with(~ gsub("%", "pct", .x, fixed = TRUE)) %>%     # replace % with pct
  rename_with(~ make.names(.x))                              # make syntactically valid names

# Example: if your column names were "danceability_%" and "energy_%", they'll become "danceability_pct" and "energy_pct"
# Confirm that important columns exist
required_cols <- c("streams", "in_spotify_playlists", "danceability_pct", "energy_pct", "valence_pct",
                   "artist_count", "released_year")
missing_cols <- setdiff(required_cols, names(spotify))
if (length(missing_cols) > 0) stop("Missing columns in dataset: ", paste(missing_cols, collapse = ", "))

# Convert types
spotify <- spotify %>%
  mutate(
    streams = as.numeric(streams),
    in_spotify_playlists = as.numeric(in_spotify_playlists),
    danceability_pct = as.numeric(danceability_pct),
    energy_pct = as.numeric(energy_pct),
    valence_pct = as.numeric(valence_pct),
    artist_count = as.integer(artist_count),
    released_year = as.integer(released_year),
    # create factors if helpful for plotting (not used in model)
    released_year_f = factor(released_year)
  ) %>%
  drop_na(streams, in_spotify_playlists, danceability_pct, energy_pct, valence_pct, artist_count, released_year)

# ------------------ 3) Fit the exact specified model (raw streams) ------------------
# ORIGINAL MODEL (before fixing heteroskedasticity)
m0 <- lm(streams ~ in_spotify_playlists + danceability_pct + energy_pct +
           valence_pct + artist_count + released_year +
           danceability_pct * energy_pct,
         data = spotify)

# Tidy summary
summary_raw <- summary(model_raw)
print(summary_raw)

# Tidy coefficients table
coefs_raw <- broom::tidy(model_raw) %>%
  mutate(estimate = round(estimate, 2),
         std.error = round(std.error, 2),
         statistic = round(statistic, 2),
         p.value = signif(p.value, 3))
print(coefs_raw)

# ------------------ 4) Multicollinearity check (VIF) ------------------
vif_vals <- car::vif(model_raw)
vif_df <- enframe(vif_vals, name = "term", value = "VIF")
print(vif_df)

# ------------------ 5) Optional: Fit log-transformed streams model for heteroskedasticity
# (recommended for diagnostics; keep the raw model as primary since you asked for the exact formula)
spotify <- spotify %>% mutate(log_streams = log1p(streams)) # log1p handles zeros safely
formula_log <- as.formula("log_streams ~ in_spotify_playlists + danceability_pct + energy_pct + valence_pct + artist_count + released_year + danceability_pct:energy_pct")
model_log <- lm(formula_log, data = spotify)
summary(model_log)

# ------------------ 6) Create figures directory ------------------
if (!dir.exists("figures")) dir.create("figures")

# ===== Packages needed =====
pkgs2 <- c("lmtest", "sandwich", "MASS", "caret", "Metrics", "broom", "car")
invisible(lapply(pkgs2, function(p) if (!requireNamespace(p, quietly = TRUE)) install.packages(p)))
library(lmtest); library(sandwich); library(MASS); library(caret); library(Metrics); library(broom); library(car)

# ----- A. Formal heteroskedasticity test (Breusch-Pagan) -----
bp_test <- lmtest::bptest(model_raw)
print(bp_test)
# On poster: report bp_test$statistic and bp_test$p.value

# ----- B. Try Box-Cox to see an optimal transform (applies to positive streams) -----
# BoxCox requires strictly positive response: streams > 0
if (all(spotify$streams > 0)) {
  bc <- MASS::boxcox(model_raw, plotit = FALSE)
  lambda_opt <- bc$x[which.max(bc$y)]
  cat("Box-Cox suggested lambda =", lambda_opt, "\n")
} else {
  cat("Box-Cox skipped (non-positive streams present). Consider log1p instead.\n")
}

# ----- C. Refit using log1p(streams) if heteroskedasticity present -----
spotify$log_streams <- log1p(spotify$streams)
model_log <- lm(log_streams ~ in_spotify_playlists + danceability_pct + energy_pct + valence_pct + artist_count + released_year + danceability_pct:energy_pct, data = spotify)
summary(model_log)
# Diagnostics for log model
bp_log <- lmtest::bptest(model_log)
print(bp_log)

# ----- D. Robust (HC) standard errors for raw model coefficients -----
coeftest_raw_HC <- lmtest::coeftest(model_raw, vcov = sandwich::vcovHC(model_raw, type = "HC3"))
print(coeftest_raw_HC)
# On poster: show coefficients with robust SEs and robust p-values

# ----- E. Weighted Least Squares (WLS) approach -----
# 1. Fit model, compute squared residuals, regress squared residuals on fitted values to estimate variance function
resid_sq <- residuals(model_raw)^2
fit_vals <- fitted(model_raw)
wmodel_var <- lm(resid_sq ~ fit_vals)
# predicted variance (avoid zeros)
pred_var <- pmax(predict(wmodel_var), 1e-6)
weights <- 1 / pred_var
# 2. Refit with weights
model_wls <- lm(formula(model_raw), data = spotify, weights = weights)
summary(model_wls)
# Diagnostics
bp_wls <- lmtest::bptest(model_wls)
print(bp_wls)

# ----- F. Influence diagnostics (leverage & Cook's distance) -----
inf <- influence.measures(model_raw)
# identify high leverage or high Cook's distance
cd <- cooks.distance(model_raw)
high_cd <- which(cd > (4 / nrow(spotify)))  # conventional rule
length(high_cd)
# Optionally inspect top influential points
top_inf <- head(order(cd, decreasing = TRUE), 10)
data.frame(row = top_inf, cooks_d = round(cd[top_inf], 4))

# ----- G. Multicollinearity check (VIF) -----
vifs <- car::vif(model_raw)
print(vifs)

# ----- H. k-fold cross-validation (5-fold) to compare raw vs log vs WLS model predictive RMSE -----
set.seed(2025)
k <- 5
# Use caret::train for consistent CV. Create custom training function for raw (predicting streams)
ctrl <- caret::trainControl(method = "cv", number = k)

# raw model formula
form_raw <- formula(model_raw)
# caret requires a method; use "lm"
cv_raw <- caret::train(form_raw, data = spotify, method = "lm", trControl = ctrl)
cv_raw$results  # RMSE on original scale (caret uses resampling on response scale)

# log model CV (predict log_streams)
form_log <- formula(model_log)
cv_log <- caret::train(form_log, data = spotify, method = "lm", trControl = ctrl)
cv_log$results

# For WLS, caret doesn't directly support weights in train; do manual CV for WLS RMSE:
folds <- caret::createFolds(spotify$streams, k = k)
rmse_wls_folds <- sapply(folds, function(idx_test){
  test <- spotify[idx_test, ]
  train <- spotify[-idx_test, ]
  m_train <- lm(streams ~ in_spotify_playlists + danceability_pct + energy_pct + valence_pct + artist_count + released_year + danceability_pct:energy_pct, data = train)
  # estimate variance function on train
  pred_train <- predict(m_train)
  res_sq_train <- residuals(m_train)^2
  vfit <- lm(res_sq_train ~ pred_train)
  pred_var_train <- pmax(predict(vfit, newdata = data.frame(pred_train = predict(m_train, newdata = test))), 1e-6)
  wts_test <- 1 / pred_var_train
  m_wls_test <- lm(formula(m_train), data = train, weights = 1 / pmax(predict(vfit), 1e-6))
  # predict on test
  pred_test <- predict(m_wls_test, newdata = test)
  Metrics::rmse(test$streams, pred_test)
})
mean_rmse_wls <- mean(rmse_wls_folds)
cat("WLS CV RMSE (approx):", mean_rmse_wls, "\n")

# ----- I. Model performance summary (Adj R^2, RMSE, MAE) for raw/log/WLS -----
# Raw:
adj_r2_raw <- summary(model_raw)$adj.r.squared
rmse_raw <- Metrics::rmse(spotify$streams, predict(model_raw))
mae_raw <- Metrics::mae(spotify$streams, predict(model_raw))
# Log (on log scale)
adj_r2_log <- summary(model_log)$adj.r.squared
rmse_log <- Metrics::rmse(spotify$log_streams, predict(model_log))
mae_log <- Metrics::mae(spotify$log_streams, predict(model_log))
# WLS:
adj_r2_wls <- summary(model_wls)$adj.r.squared
rmse_wls <- Metrics::rmse(spotify$streams, predict(model_wls))
mae_wls <- Metrics::mae(spotify$streams, predict(model_wls))

perf_table <- tibble(
  Model = c("Raw (OLS)", "Log(1+streams)", "WLS (resid var)"),
  Adj_R2 = c(adj_r2_raw, adj_r2_log, adj_r2_wls),
  RMSE = c(rmse_raw, rmse_log, rmse_wls),
  MAE = c(mae_raw, mae_log, mae_wls)
)
print(perf_table)
# Save table for poster
if (!dir.exists("figures")) dir.create("figures")
write_csv(perf_table, "figures/model_performance_comparison.csv")
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
# ------------------ 7) Figure A: Histograms / density plots for streams, danceability_pct, energy_pct ------------------
# A1: Streams histogram + density
p_streams <- ggplot(spotify, aes(x = streams)) +
  geom_histogram(bins = 60, alpha = 0.8) +
  labs(title = "Histogram of Spotify Streams", x = "Streams", y = "Count") +
  theme_minimal()
ggsave("figures/hist_streams.png", p_streams, width = 6, height = 4, dpi = 300)

# A2: Streams (log) histogram — often more informative
p_log_streams <- ggplot(spotify, aes(x = log1p(streams))) +
  geom_histogram(bins = 60, alpha = 0.8) +
  labs(title = "Histogram of log(1 + Streams)", x = "log(1 + Streams)", y = "Count") +
  theme_minimal()
ggsave("figures/hist_log_streams.png", p_log_streams, width = 6, height = 4, dpi = 300)

# A3: Danceability density/hist
p_dance <- ggplot(spotify, aes(x = danceability_pct)) +
  geom_density() +
  geom_rug(alpha = 0.2) +
  labs(title = "Density of Danceability (%)", x = "Danceability (%)") +
  theme_minimal()
ggsave("figures/density_danceability.png", p_dance, width = 5, height = 3.5, dpi = 300)

# A4: Energy density/hist
p_energy <- ggplot(spotify, aes(x = energy_pct)) +
  geom_density() +
  geom_rug(alpha = 0.2) +
  labs(title = "Density of Energy (%)", x = "Energy (%)") +
  theme_minimal()
ggsave("figures/density_energy.png", p_energy, width = 5, height = 3.5, dpi = 300)

# ------------------ 8) Figure B: Clean coefficient table plot (dot-and-whisker) ------------------
# Use broom::tidy to make a plot of estimates with 95% CIs
coefs_plot_dat <- broom::tidy(model_raw) %>%
  filter(term != "(Intercept)") %>%
  mutate(term = fct_reorder(term, estimate))

p_coefs <- ggplot(coefs_plot_dat, aes(x = estimate, y = term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = estimate - 1.96*std.error, xmax = estimate + 1.96*std.error), height = 0.2) +
  labs(title = "Coefficient Estimates (raw streams model)", x = "Estimate", y = "") +
  theme_minimal()
ggsave("figures/coef_estimates_raw.png", p_coefs, width = 7, height = 4, dpi = 300)

# Also export a neat table for the poster (rounded)
coefs_table <- broom::tidy(model_raw) %>%
  mutate(estimate = round(estimate, 0),
         std.error = round(std.error, 0),
         p.value = signif(p.value, 3)) %>%
  select(term, estimate, std.error, p.value)
write_csv(coefs_table, "figures/coef_table_raw.csv")

# ------------------ 9) Figure C: Interaction plot (predicted streams across danceability at low/med/high energy) ------------------
# Create grid of danceability_pct and energy_pct values
dance_seq <- seq(min(spotify$danceability_pct, na.rm = TRUE),
                 max(spotify$danceability_pct, na.rm = TRUE), length.out = 100)
energy_low <- quantile(spotify$energy_pct, 0.25, na.rm = TRUE)
energy_med <- quantile(spotify$energy_pct, 0.5, na.rm = TRUE)
energy_high <- quantile(spotify$energy_pct, 0.75, na.rm = TRUE)

newdata <- expand.grid(
  in_spotify_playlists = median(spotify$in_spotify_playlists, na.rm = TRUE),
  danceability_pct = dance_seq,
  energy_pct = c(energy_low, energy_med, energy_high),
  valence_pct = median(spotify$valence_pct, na.rm = TRUE),
  artist_count = round(median(spotify$artist_count, na.rm = TRUE)),
  released_year = round(median(spotify$released_year, na.rm = TRUE))
)

# Predict using the raw model (on original scale)
newdata$pred_streams <- predict(model_raw, newdata = newdata, interval = "confidence")[, "fit"]
# Bind energy level labels
newdata <- newdata %>%
  mutate(energy_level = case_when(
    energy_pct == energy_low ~ "Low energy (25th pctile)",
    energy_pct == energy_med ~ "Median energy (50th pctile)",
    energy_pct == energy_high ~ "High energy (75th pctile)"
  ))

p_interaction <- ggplot(newdata, aes(x = danceability_pct, y = pred_streams, color = energy_level)) +
  geom_line(size = 1) +
  labs(title = "Interaction: Predicted Streams by Danceability across Energy Levels",
       x = "Danceability (%)", y = "Predicted Streams", color = "Energy level") +
  theme_minimal()
ggsave("figures/interaction_pred_streams_raw.png", p_interaction, width = 7, height = 4, dpi = 300)

# If you'd prefer the interaction plot on log-scale predictions (often clearer):
newdata$pred_log <- predict(model_log, newdata = newdata, interval = "confidence")[, "fit"]
p_interaction_log <- ggplot(newdata, aes(x = danceability_pct, y = expm1(pred_log), color = energy_level)) +
  geom_line(size = 1) +
  labs(title = "Interaction (log-model back-transformed): Predicted Streams by Danceability",
       x = "Danceability (%)", y = "Predicted Streams (back-transformed)") +
  theme_minimal()
ggsave("figures/interaction_pred_streams_log_backtrans.png", p_interaction_log, width = 7, height = 4, dpi = 300)

# ------------------ 10) Figure D: Residual diagnostics ------------------
# Residual vs Fitted Plot — BEFORE Fix
resid_dat <- augment(model_raw)
p_resid_fitted <- ggplot(resid_dat, aes(x = .fitted, y = .resid)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype = 2) +
  labs(title = "Residuals vs Fitted (raw model)", x = "Fitted values", y = "Residuals") +
  theme_minimal()
ggsave("figures/resid_vs_fitted_raw.png", p_resid_fitted, width = 6, height = 4, dpi = 300)

transStreams <- (spotify$streams)^0.2
model2 <- lm(transStreams ~ in_spotify_playlists + danceability_pct + energy_pct +
           valence_pct + artist_count + released_year +
           danceability_pct * energy_pct,
         data = spotify)
e_hat <- resid(model2)
y_hat <- fitted(model2)
p_resid_fitted <- ggplot(spotify, aes(x = e_hat, y = y_hat)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype = 2) +
  labs(title = "Residuals vs Fitted (transformed model)", x = "Fitted values", y = "Residuals") +
  theme_minimal()
ggsave("figures/resid_vs_fitted_transformed.png", p_resid_fitted, width = 6, height = 4, dpi = 300)

p <- powerTransform(cbind(resid_dat[,2:6]))
summary(p)
model3 <- lm(transStreams ~ log(in_spotify_playlists) + log(danceability_pct) + log(energy_pct) +
           sqrt(valence_pct) + 1/artist_count + log(released_year) +
           log(danceability_pct * energy_pct),
         data = spotify)
e_hat <- resid(model3)
y_hat <- fitted(model3)
plot(e_hat ~ y_hat, xlab="Fitted Values", ylab="Residuals")
plot(e_hat ~ log(spotify$in_spotify_playlists), xlab="ln(AdPages)", ylab="Residuals")
plot(e_hat ~ log(spotify$danceability_pct), xlab="ln(AdPages)", ylab="Residuals")
plot(e_hat ~ log(spotify$energy_pct), xlab="ln(SubRevenue)", ylab="Residuals")
plot(e_hat ~ sqrt(spotify$valence_pct), xlab="ln(NewsRevenue)", ylab="Residuals")
plot(e_hat ~ 1/(spotify$artist_count), xlab="ln(NewsRevenue)", ylab="Residuals")
plot(e_hat ~ log(spotify$released_year), xlab="ln(SubRevenue)", ylab="Residuals")
plot(e_hat ~ log(spotify$danceability_pct * spotify$energy_pct), xlab="ln(SubRevenue)", ylab="Residuals")
qqnorm(e_hat); qqline(e_hat)

# Residual vs Fitted Plot — AFTER Fix
resid_dat_after <- augment(lm(log(streams) ~ in_spotify_playlists + danceability_pct + energy_pct +
           valence_pct + artist_count + released_year +
           danceability_pct * energy_pct,
         data = spotify))
p_resid_fitted_after <- ggplot(resid_dat_after, aes(x = .fitted, y = .resid)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype = 2) +
  labs(title = "Residuals vs Fitted (log-transformed model)",
       x = "Fitted values",
       y = "Residuals") +
  theme_minimal()
ggsave("figures/resid_vs_fitted_log.png", p_resid_fitted_after,
       width = 6, height = 4, dpi = 300)

# Residuals vs in_spotify_playlists (to check heteroskedasticity vs exposure)
p_resid_spotifyPlaylists <- ggplot(resid_dat, aes(x = in_spotify_playlists, y = .resid)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "loess", se = FALSE) +
  labs(title = "Residuals vs In-Spotify-Playlists", x = "In Spotify playlists", y = "Residuals") +
  theme_minimal()
ggsave("figures/resid_vs_spotify_playlists_raw.png", p_resid_spotifyPlaylists, width = 6, height = 4, dpi = 300)

# QQ-plot of residuals
p_qq <- ggplot(resid_dat, aes(sample = .resid)) +
  stat_qq() +
  stat_qq_line() +
  labs(title = "Normal Q-Q Plot of Residuals (raw model)") +
  theme_minimal()
ggsave("figures/qqplot_resid_raw.png", p_qq, width = 6, height = 4, dpi = 300)

# Scale-Location plot (sqrt(|resid|)
p_scale_loc <- ggplot(resid_dat, aes(x = .fitted, y = sqrt(abs(.resid)))) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "loess", se = FALSE) +
  labs(title = "Scale-Location Plot", x = "Fitted values", y = "Sqrt(|Residuals|)") +
  theme_minimal()
ggsave("figures/scale_location_raw.png", p_scale_loc, width = 6, height = 4, dpi = 300)

# ------------------ 11) Optional: Save model summaries and diagnostics to files ------------------
capture.output(summary_raw, file = "figures/model_raw_summary.txt")
capture.output(vif_df, file = "figures/vif_values.txt")
capture.output(summary(model_log), file = "figures/model_log_summary.txt")

# ------------------ 12) Notes for poster captions & interpretation (print a short summary) ------------------
cat("\n\n=== Poster notes (copy into poster): ===\n")
cat("- Model formula (raw):", deparse(formula_raw), "\n")
cat("- Top results: inspect 'figures/coef_table_raw.csv' and 'figures/coef_estimates_raw.png'\n")
cat("- Interaction plot saved to: figures/interaction_pred_streams_raw.png (raw) and figures/interaction_pred_streams_log_backtrans.png (log-model back-transformed)\n")
cat("- Diagnostics saved to: figures/resid_vs_fitted_raw.png, figures/resid_vs_spotify_playlists_raw.png, figures/qqplot_resid_raw.png, figures/scale_location_raw.png\n")
cat("- Consider reporting results from the log-model (figures/model_log_summary.txt) if heteroskedasticity present.\n")
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
